{"meta":{"title":"pdChen的博客","subtitle":"前端技术学习","description":null,"author":"chenyu","url":"https://romancy.github.io","root":"/"},"pages":[],"posts":[{"title":"动态生成a标签进行下载","slug":"动态生成a标签进行下载","date":"2019-09-09T03:19:50.000Z","updated":"2019-09-09T03:20:50.308Z","comments":true,"path":"2019/09/09/动态生成a标签进行下载/","link":"","permalink":"https://romancy.github.io/2019/09/09/动态生成a标签进行下载/","excerpt":"","text":"12345678910111213141516171819202122const randomString = function(len) &#123; len = len || 8; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;export default function (url) &#123; let a = document.createElement('a'); a.setAttribute('href', downloadUrl); a.setAttribute('id', hash); if(document.getElementById(hash)) &#123; document.body.removeChild(document.getElementById(hash)); &#125; document.body.appendChild(a); document.getElementById(hash).click(); document.body.removeChild(document.getElementById(hash));&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"indexedDB基础操作","slug":"indexedDB基础操作","date":"2019-09-09T03:17:23.000Z","updated":"2019-09-09T03:17:53.973Z","comments":true,"path":"2019/09/09/indexedDB基础操作/","link":"","permalink":"https://romancy.github.io/2019/09/09/indexedDB基础操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class SetDB &#123; constructor() &#123; this.databaseName = ''; this.tableName = ''; this.db = null; this.indexedDB = null; &#125; init(databaseName, tableName) &#123; this.databaseName = databaseName; this.tableName = tableName; let self = this; this.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB; if (!this.indexedDB) &#123; console.log('你的浏览器不支持IndexedDB'); &#125; let IDBOpenDBRequest = this.indexedDB.open(self.databaseName, 1); IDBOpenDBRequest.onerror = function (e) &#123; console.log(e.currentTarget.error.message); &#125;; IDBOpenDBRequest.onupgradeneeded = function (e) &#123; self.db = e.target.result; // 获取到 demoDB对应的 IDBDatabase实例,也就是我们的数据库。 if (!self.db.objectStoreNames.contains(self.tableName)) &#123; //如果表格不存在，创建一个新的表格（keyPath，主键 ； autoIncrement,是否自增），会返回一个对象（objectStore） // objectStore就相当于数据库中的一张表。IDBObjectStore类型。 self.db.createObjectStore(self.tableName, &#123; keyPath: 'id', &#125;); &#125; &#125;; &#125; open(fn) &#123; let self = this; let IDBOpenDBRequest = this.indexedDB.open(self.databaseName, 1); IDBOpenDBRequest.onsuccess = function (e) &#123; fn &amp;&amp; fn(e.target.result) &#125;; &#125; add(data) &#123; let self = this; self.open(db =&gt; &#123; var transaction = db.transaction(self.tableName, 'readwrite'); // 通过事务来获取IDBObjectStore var store = transaction.objectStore(self.tableName); // 往store表中添加数据 var addPersonRequest = store.add(data); // 监听添加成功事件 addPersonRequest.onsuccess = function (e) &#123; console.log(e.target.result); // 打印添加成功数据的 主键（id） &#125;; // 监听失败事件 addPersonRequest.onerror = function (e) &#123; console.log(e.target.error); &#125;; &#125;) &#125; putData(data) &#123; let self = this; self.open(db =&gt; &#123; let store = db.transaction(self.tableName, 'readwrite').objectStore(self.tableName); let request = store.put(data); request.onerror = function () &#123; console.error('put添加数据库中已有该数据') &#125;; request.onsuccess = function () &#123; console.log('put添加数据已存入数据库') self.getAll(data =&gt; &#123; data.sort((a, b) =&gt; &#123; return b.time - a.time &#125;) for (let i = 100; i &lt; data.length; i++) &#123; // 删除超过数量的照片 self.deleteData(data[i].id) &#125; &#125;) &#125;; &#125;) &#125; getAll(callback) &#123; let self = this; this.open(db =&gt; &#123; let data = [] var transaction = db.transaction(self.tableName, 'readwrite'); var store = transaction.objectStore(self.tableName); var dataRequest = store.openCursor(); dataRequest.onsuccess = function (e) &#123; //异步的 let result = e.target.result; if (result &amp;&amp; result !== null) &#123; data.push(result.value); result.continue(); &#125; else &#123; console.log('全部查找数据成功') callback &amp;&amp; callback(data); &#125; &#125; &#125;) &#125; deleteData(key) &#123; let self = this; this.open(db =&gt; &#123; let store = db.transaction(self.tableName, 'readwrite').objectStore(self.tableName); let request = store.delete(key); request.onerror = function () &#123; console.error('删除失败') &#125;; request.onsuccess = function () &#123; console.log('删除成功') &#125;; &#125;) &#125; deleteDB() &#123; this.indexedDB.deleteDatabase(databaseName); &#125;&#125;export default new SetDB()","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"写一个hash值","slug":"写一个hash值","date":"2019-09-09T03:15:35.000Z","updated":"2019-09-09T03:16:37.944Z","comments":true,"path":"2019/09/09/写一个hash值/","link":"","permalink":"https://romancy.github.io/2019/09/09/写一个hash值/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940//产生一个hash值，只有数字，规则和java的hashcode规则相同let hashCode = (str)=&gt;&#123; let h = 0; let len = str.length; let t = 2147483648; for (let i = 0; i &lt; len; i++) &#123; h = 31 * h + str.charCodeAt(i); if (h &gt; 2147483647) h %= t; //java int溢出则取模 &#125; return h;&#125;;let randomWord = (randomFlag, min, max)=&gt;&#123; let str = \"\", pos, range = min, arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']; // 随机产生 if (randomFlag) &#123; range = Math.round(Math.random() * (max - min)) + min; &#125; for (let i = 0; i &lt; range; i++) &#123; pos = Math.round(Math.random() * (arr.length - 1)); str += arr[pos]; &#125; return str;&#125;;// 获取hashlet gethashcode = () =&gt; &#123; //定义一个时间戳，计算与1970年相差的毫秒数 用来获得唯一时间 let timestamp = (new Date()).valueOf(); let myRandom = randomWord(true,2,8); let hashData = hashCode(myRandom+timestamp.toString()); return hashData;&#125;;export default &#123; gethashcode&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"cookie操作","slug":"cookie操作","date":"2019-09-09T03:13:11.000Z","updated":"2019-09-09T03:14:35.809Z","comments":true,"path":"2019/09/09/cookie操作/","link":"","permalink":"https://romancy.github.io/2019/09/09/cookie操作/","excerpt":"","text":"1234567891011121314151617181920export default &#123; setCookie: function (cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = \"expires=\" + d.toUTCString(); document.cookie = cname + \"=\" + cvalue + \"; \" + expires; // console.info(document.cookie); &#125;,//获取cookie getCookie: function (cname) &#123; var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == ' ') c = c.substring(1); if (c.indexOf(name) != -1) return c.substring(name.length, c.length); &#125; return \"\"; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"我理解的js异步编程","slug":"我理解的js异步编程","date":"2019-09-09T02:22:20.000Z","updated":"2019-09-09T02:25:38.889Z","comments":true,"path":"2019/09/09/我理解的js异步编程/","link":"","permalink":"https://romancy.github.io/2019/09/09/我理解的js异步编程/","excerpt":"","text":"我理解的JavaScript异步编程引言最开始学习JS的时候就从知道了JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型。但是，多数初学者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法，甚至于一直在用callback来解决异步问题。 为什么会出现异步浏览器内核的多线程 一个浏览器至少三个常驻线程：JavaScript引擎线程，浏览器GUI渲染线程，浏览器事件触发线程。 JS引擎，是基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。 GUI线程，当界面需要重绘或由于某种操作引发回流时，该线程就会执行。而因为JS可以操作DOM元素，进而会影响到GUI的渲染结果，因此JS引擎线程与GUI渲染线程是互斥的，也就是说当JS引擎线程处于运行状态时，GUI渲染线程将处于冻结状态。 浏览器事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待js引擎的处理，这些事件可来自JavaScript引擎当前执行的代码块，setTimeOut, 也可以来自浏览器内核的其他线程如鼠标点击，AJAX异步请求等，但由于JS的单线程关系，所有这些事件都得排队等待JS引擎处理。 事件循环机制 任务队列，也就是事件队列，分为 宏任务(macro-task) 和 微任务(micro-task) 循环机制如下 先顺序从上向下执行当前全局上下文 遇到异步事件就将其交给对应的浏览器模块 浏览器的模块处理完之后，宏任务放入宏任务队列，微任务放入微任务队列 当函数调用栈清空，开始执行任务队列，先执行微任务队列，执行完微任务队列再执行宏任务队列 当执行任务队列时，可以认为重新开了一个空的宏任务队列和一个空的微任务队列，将新产生的异步任务最终放入新的任务队列，当前任务队列执行完成后，当前宏队列和微队列就清除，然后再去执行新的微任务队列，执行新的宏任务队列，新开微队列，新开宏队列，一直循环下去，直到任务队列全部为空。 异步的处理方法callback是最简单的，但不是最好的12345678910111213141516171819//callback的一般使用形式$.ajax(&#123; url:'www.pidanChen.com' success:function(data)&#123; console.log(data) &#125;&#125;)//延时处理try&#123; setTimeout(function()&#123; console.log('timeout') &#125;,500)&#125;catch(e)&#123; console.log('timerErr'+e)&#125; 1.如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，还采用回调的方式来处理异步的话，就会出现回调地狱，也就是顺序问题。 2.最严重的还不是编辑器中出现的倒三角形的代码,是控制反转。例如，我们调用了一个第三方组件的支付API，进行购买支付，正常情况发现一切运行良好，但是假如某一天，第三方组件出问题了，可能多次调用传入的回调，也可能传回错误的数据。说到底，这样的回调嵌套，控制权在第三方，对于回调函数的调用方式、时间、次数、顺序，回调函数参数都是不可控的，因为无论如何，并不总能保证第三方是可信任的。 解决信任问题–Promise123456789//创建第一个Promiselet p = new Promise(function(res,rej)&#123; if(err)&#123; rej() &#125;else&#123; res() &#125;&#125;)p.then() 实例化一个Promise对象组要一个函数作为参数，该函数接受两个参数：resolve函数和reject函数；当实例化Promise构造函数时，将立即调用该函数，随后返回一个Promise对象。通常，实例化时，会初始一个异步任务，在异步任务完成或失败时，调用resolve或reject函数来完成或拒绝返回的Promise对象。另外需要注意的是，若传入的函数执行抛出异常，那么这个promsie将被拒绝。 解决控制反转的信任问题 Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。 它与普通的回调的方式的区别在于，普通的方式，回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。在Promise的方式中，回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。 Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。 解决调用过早Promise就根本不必担心这种问题即使是立即完成的Promise，也无法被同步观察到，即使这个Promise已经决议了，提供给then的回调总会是在js事件队列在当前完成后，再被调用，即异步调用。 解决回调过晚或没有调用Promise本身不会回调过晚，只要决议了，它就会按照规定运行。至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态API Promise.race加一个超时的时间 123456789function timeoutPromise(delay)&#123; return new Promise(function(res,rej)&#123; setTimeout(function()&#123; rej('timeout') &#125;, delay) &#125;)&#125;Promise.race([dosomeThing(), timeoutPromise(3000)]).then().catch() 解决回调次数太少或太多的问题由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。 12345678910111213141516171819let fs = require('fs');var p1 = new Promise(function (resolve, reject) &#123; fs.readFile('a.txt', 'utf8', function (err, data) &#123; if (err) &#123; reject(err); &#125; resolve(data); resolve(data); resolve(data); resolve(data); resolve(data); resolve(data); resolve(data); &#125;)&#125;);p1.then(function(res)&#123; &lt;!--只打印一次res--&gt; console.log(res)&#125;) 解决吞掉可能出现的错误或异常如果在Promise的创建过程中或在查看其决议结果的过程中的任何时间点上，出现了一个JavaScript异常错误，比如一个TypeError或ReferenceError，这个异常都会被捕捉，并且会使这个Promise被拒绝。 12345678910var p = new Promise(function (resolve, reject) &#123; foo.bar(); // foo未定义 resolve(2);&#125;);p.then(function (data) &#123; console.log(data); // 永远也不会到达这里&#125;, function (err) &#123; // console.log(err); // err将会是一个TypeError异常对象来自foo.bar()这一行&#125;); 从以上几点可以明确，Promise可以解决一系列控制反转带来的回调信任问题，但是Promise并没有完全摆脱回调，而是把回调的位置放到了then中，换成了决议通知，这样其实说到底顺序问题还是没有解决。。 解决顺序问题–Generator。生成器 (Generator)生成器是一种返回迭代器的函数，通过 function 关键字后的 * 号来表示。 迭代器（Iterable）迭代器是一种对象，它具有一些专门为迭代过程设计的专有接口，所有迭代器对象都有一个 next 方法，每次调用都返回一个结果对象。结果对象有两个属性，一个是 value，表示下一个将要返回的值；另一个是 done，它是一个布尔类型的值，当没有更多可返回数据时返回 true。迭代器还会保存一个内部指针，用来指向当前集合中值的位置，每调用一次 next() 方法，都会返回下一个可用的值。 生成器一般使用形式123456789101112function *foo() &#123; var x = yield 2; var y = x * (yield x + 1) console.log( x, y ); return x + y&#125;var it = foo();it.next() // &#123;value: 2, done: false&#125;it.next(3) // &#123;value: 4, done: false&#125;it.next(3) // 3 9, &#123;value: 12, done: true&#125; yield.. 和 next(..) 这一对组合起来， 在生成器的执行过程中构成了一个双向消息传递系统。 一般来说，需要的 next(..) 调用要比 yield 语句多一个，前面的代码片段有两个 yield 和三个 next(..) 调用； 第一个 next(..)是用来启动一个生成器，并运行到第一个 yield 处; 每个 yield.. 基本上是提出了一个问题：“这里我应该插入什么值？”，这个问题由下一个 next(..) 回答。 第二个 next(..) 回答第一个 yield.. 的问题，第三个 next(..) 回答第二个 yield 的问题，以此类推； yield.. 作为一个表达式可以发出消息响应 next(..) 调用， next(..) 也可以向暂停的 yield 表达式发送值。 异步迭代生成器来看一下下面这段代码，我们在生成器里 yeild 请求函数（暂停生成器继续执行，同时并执行请求函数），执行生成器产成可迭代对象后，又在请求函数里通过 next() 方法获取到请求结果、将结果传进生成器并恢复生成器的执行。 1234567891011121314151617181920212223242526272829//setTimeout 模拟ajax请求var it=nullfunction foo()&#123; let firstData='firstData' setTimeout(function()&#123; it.next(firstData) &#125;,500)&#125;function goo(data)&#123; let secondData='secondData' setTimeout(function()&#123; if(data=='firstData')&#123; it.next(`$&#123;secondData&#125;+$&#123;data&#125;`) &#125; &#125;,500)&#125;function *main()&#123; let data=yield foo() let newData=yield goo(data) console.log('经过两次异步之后输出结果:'+newData)&#125;it=main();it.next() //启动&lt;!--输出--&gt;经过两次异步之后输出结果:secondData+firstData 我们在生成器内部有了看似完全同步的代码（除了 yield 关键字本身），但隐藏在背后的是，在 foo(..) goo(…)内的运行可以完全异步。在可读性和合理性方面也都是一个巨大的进步。 从本质上而言，我们把异步作为实现细节抽象了出去，使得我们可以以同步顺序的形式追踪流程控制：“发出一个 Ajax 请求，等它完成之后打印出响应结果。”并且只在这个流程控制中表达了两个步骤，而这种表达能力是可以无限扩展的，以便我们无论需要多少步骤都可以表达。 由以上来看，顺序问题也得到了解决 es7的解决方案 Async/Await上面介绍的Promise和Generator，把这两者结合起来，就是Async/Await。 Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。 Async/Await是Generator的语法糖，和generator的写法很像，就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成await。 内置执行器：Generator函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器.也就是说，async 函数的执行，与普通函数一模一样。 更好的语义：async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 async 的作用async 函数负责返回一个 Promise 对象如果在async函数中 return 一个直接量，async 会把这个直接量通过Promise.resolve() 封装成 Promise 对象;如果 async 函数没有返回值,它会返回 Promise.resolve(undefined) await在等待什么一般我们都用await去等带一个async函数完成，不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值，所以，await后面实际可以接收普通函数调用或者直接量 如果await等到的不是一个promise对象，那跟着的表达式的运算结果就是它等到的东西；如果是一个promise对象，await会阻塞后面的代码，等promise对象resolve，得到resolve的值作为await表达式的运算结果虽然await阻塞了，但await在async中，async不会阻塞，它内部所有的阻塞都被封装在一个promise对象中异步执行 Async Await使用场景当需要用到promise链式调用的时候，就体现出Async Await的优势； 12345678910111213141516171819202122232425function delayTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return delayTime(n);&#125;function step2(m, n) &#123; console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`); return delayTime(m + n);&#125;async function main() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2);&#125;main();&lt;!--输出结果--&gt;step1 with 300step2 with 300 and 500 await 若等待的是 promise 就会停止下来例如：业务是这样的，我有三个异步请求需要发送，相互没有关联，只是需要当请求都结束后将界面的 loading 清除掉即可。 之前用callback这么写 1234567let lock=0ajax(function()&#123; lock++ if(lock===3)&#123; clearLoading()// 清除loading &#125;&#125;) 现在用 Async/Await 1234567// ajax方法返回的是promise对象async function doIt()&#123; await ajax(1) await ajax(2) await ajax(3) clearLoading()&#125; #####loading 确实是等待请求都结束完才清除的。但是观察下浏览器的 timeline 请求是一个结束后再发另一个的 正常应该是利用Promise.all + async 1234567async function doIt()&#123; let p1=ajax(1) let p2=ajax(2) let p3=ajax(3) await Promise.all([p1,p2,p3]); clearLoading()&#125; 所以async-await并不能取代promise，两者应该是相互配合。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"Vue工程搭建详细","slug":"Vue工程搭建详细","date":"2019-09-06T07:06:48.000Z","updated":"2019-09-09T03:03:31.395Z","comments":true,"path":"2019/09/06/Vue工程搭建详细/","link":"","permalink":"https://romancy.github.io/2019/09/06/Vue工程搭建详细/","excerpt":"","text":"Vue工程搭建详细以下是我开始做vue以来所遇到的一些问题及解决方法环境搭建安装vue脚手架 npm i vue-cli -g 检验是否安装成功执行命令 vue -V 用webpack模板搭建vue工程 vue init webpack 进入到项目里安装依赖并执行启动命令 npm i &amp;&amp; npm run dev 打开浏览器访问127.0.0.1：8080即可看到 项目开发api封装在src目录下新建目录request，目录结构如下 api 为所有api配置，如method，url config 为基础配置 core 为所有核心api调用方法 index 入口 utils 工具方法 写好之后在项目main.js中进行挂载 1Vue.prototype['$myReq'] = request 详细代码：略 引入element安装 npm i element-ui -S 在工程main中添加引用 1234import elementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'Vue.use(elementUI) 然后在项目里就可以直接使用了 本地测试解决接口跨域问题在本地启动vue项目是常常会遇到接口跨域问题，解决方案有好多种。现在介绍的是个人认为最好用的方法，proxyTable。 用proxyTable的前提是要把大部分接口url比较统一如下面这样 那么proxyTable里面就可以写一套配置就可以了 1234567proxyTable: &#123; '/apis': &#123; // 测试环境 target: 'http://127.0.0.1:7001', // 接口域名 changeOrigin: true, //是否跨域 &#125;&#125;, 配置好之后再去访问就可以了","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://romancy.github.io/tags/Vue/"}]},{"title":"node核心模块--fs","slug":"node核心模块-fs","date":"2019-08-22T03:28:31.000Z","updated":"2019-08-26T02:23:13.313Z","comments":true,"path":"2019/08/22/node核心模块-fs/","link":"","permalink":"https://romancy.github.io/2019/08/22/node核心模块-fs/","excerpt":"","text":"node核心模块–fs重命名文件","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://romancy.github.io/tags/node/"}]},{"title":"如何发布一个npm包","slug":"如何发布一个npm包","date":"2019-08-21T09:58:56.000Z","updated":"2019-08-22T03:12:11.423Z","comments":true,"path":"2019/08/21/如何发布一个npm包/","link":"","permalink":"https://romancy.github.io/2019/08/21/如何发布一个npm包/","excerpt":"","text":"如何发布一个npm包 npm config set registry http://registry.npmjs.org npm get registry =&gt; http://registry.npmjs.org/ 登录 npm adduser Username: pdyu Password: Email: (this IS public) yu824562457@qq.com Logged in as pdyu on http://registry.npmjs.org/. npm publish pdc-cli-test@1.0.0","categories":[],"tags":[{"name":"utils","slug":"utils","permalink":"https://romancy.github.io/tags/utils/"}]},{"title":"node.js+commander写一个命令行工具","slug":"node-js-commander写一个命令行工具","date":"2019-08-21T06:23:45.000Z","updated":"2019-08-22T02:26:34.316Z","comments":true,"path":"2019/08/21/node-js-commander写一个命令行工具/","link":"","permalink":"https://romancy.github.io/2019/08/21/node-js-commander写一个命令行工具/","excerpt":"","text":"node.js + commander 写一个命令行工具环境搭建安装node略 初始化项目 mkdir pdc-cli &amp;&amp; cd pdc-cli npm init 安装依赖包 npm i commander -S npm i chalk -S 颜色包 npm i ora -S loading包 npm i inquirer -S 与用户交互包 npm i handlebars -S 模板渲染包 npm i log-symbols -S 终端图标包 根目录新建index.js touch index.js 编写index.js#!/usr/bin/env node在代码的开头第一行，必须指定我们的脚本执行所需要的解释程序。在这里，我们使用node来作为脚本的解释程序。而我们#! /usr/bin/env node这样写，目的是使用env来找到node，并使用node来作为程序的解释程序。 先写一个最简单的在index.js中编辑以下代码 123456789101112#!/usr/bin/env nodeconst program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')program.version(`$&#123;packageInfo.version&#125;`, '-v --version')program.parse(process.argv) 在package.json中配置命令名称及入口 123\"bin\": &#123; \"pdc\": \"index.js\"&#125; 把包link到本地全局，在项目根目录执行 npm link 在命令行输入 pdc -v 或者 pdc –version 终端会显示package.json中的version字段的值 写一个能接受用户参数的cli编辑index.js 123456789101112131415161718#!/usr/bin/env nodeconst program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; console.log(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) &#125;)program.parse(process.argv) 在命令行输入 pdc init -n test -t .src 终端输出 你输入的名字是test, 你输入的目录是.src 写一个模板拷贝的cli工具12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')// 拷贝文件到目录function copyTo(name, target)&#123; // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; console.log(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(cmd.name, cmd.target); &#125;)program.parse(process.argv) 美化一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')// 打印日志工具 不同颜色const logger = &#123; notice (msg) &#123; process.stdout.write('\\n' + chalk.cyan('[INFO]') + ' ' + msg + '\\n') &#125;, warn (msg) &#123; process.stdout.write('\\n' + chalk.yellow('[WARN]') + ' ' + msg + '\\n') &#125;, error (msg) &#123; process.stdout.write('\\n' + chalk.red('[ERROR]') + ' ' + msg + '\\n') &#125;&#125;// 拷贝文件到目录function copyTo(name, target)&#123; // loading const spinner = ora('正在拷贝...') spinner.start() // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; spinner.succeed() throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) // loading成功 spinner.succeed() // 显示成功 console.log(symbols.success, chalk.green('success')) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; logger.notice(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(cmd.name, cmd.target); &#125;)program.parse(process.argv) 换成交互式选择模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')const logger = &#123; notice (msg) &#123; process.stdout.write('\\n' + chalk.cyan('[INFO]') + ' ' + msg + '\\n') &#125;, warn (msg) &#123; process.stdout.write('\\n' + chalk.yellow('[WARN]') + ' ' + msg + '\\n') &#125;, error (msg) &#123; process.stdout.write('\\n' + chalk.red('[ERROR]') + ' ' + msg + '\\n') &#125;&#125;// 拷贝文件到目录function copyTo(name, target)&#123; const spinner = ora('正在拷贝...') spinner.start() // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; spinner.succeed() throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') // .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; // 换成可选择的 inquirer.prompt([ &#123; type: 'list', name: 'name', message: 'template name', choices: [ 'a.js', 'b.js' ] &#125; ]).then(answers =&gt; &#123; logger.notice(`你输入的名字是$&#123;answers.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(answers.name, cmd.target); &#125;) &#125;)program.parse(process.argv)","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://romancy.github.io/tags/node/"}]},{"title":"获取类型","slug":"获取类型","date":"2019-08-21T06:05:58.000Z","updated":"2019-08-21T06:06:58.085Z","comments":true,"path":"2019/08/21/获取类型/","link":"","permalink":"https://romancy.github.io/2019/08/21/获取类型/","excerpt":"","text":"能够准确获取类型如下 1234567891011121314// typeoffunction type(obj) &#123; return typeof obj !== \"object\" ? typeof obj : Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();&#125;console.log(type(1)) //numberconsole.log(type(true)) //booleanconsole.log(type('22')) //stringconsole.log(type([221,2])) //arrayconsole.log(type(&#123;a:1&#125;)) //objectconsole.log(type(new String('22'))) //stringconsole.log(type(null)) //nullconsole.log(type(undefined)) //undefinedconsole.log(type(/sd/)) //regexp","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"日期格式化","slug":"日期格式化","date":"2019-08-21T06:00:22.000Z","updated":"2019-08-21T06:01:57.456Z","comments":true,"path":"2019/08/21/日期格式化/","link":"","permalink":"https://romancy.github.io/2019/08/21/日期格式化/","excerpt":"","text":"主要是正则进行文本替换 上代码 12345678910111213141516171819202122Date.prototype.format = function (format) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //month \"d+\": this.getDate(), //day \"h+\": this.getHours(), //hour \"m+\": this.getMinutes(), //minute \"s+\": this.getSeconds(), //second \"q+\": Math.floor((this.getMonth() + 3) / 3), //quarter \"S\": this.getMilliseconds() //millisecond &#125; if (/(y+)/.test(format)) format = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(format)) format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length)); return format;&#125;;let time = new Date().format('yyyy-MM-dd hh:mm:ss')console.log(time)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"instanceof的原理及手写实现","slug":"instanceof的原理及手写实现","date":"2019-08-21T05:28:14.000Z","updated":"2019-08-21T05:52:59.443Z","comments":true,"path":"2019/08/21/instanceof的原理及手写实现/","link":"","permalink":"https://romancy.github.io/2019/08/21/instanceof的原理及手写实现/","excerpt":"","text":"instanceof 的作用简单说，instanceof的主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。 12345678910111213// A对象function A()&#123;&#125;// B对象继承A(组合继承)function B()&#123; A.apply(this, arguments)&#125;B.prototype = Object.create(A.prototype)let b = new B()console.log(b instanceof A) // true 手写实现 1234567891011121314151617function _instanceof(left, right)&#123; let _prototype = right.prototype; let _proto = left.__proto__ while(true)&#123; // 找到头了 if(_proto === null)&#123; return false &#125; if(_proto === _prototype)&#123; return true &#125; _proto = _proto.__proto__ &#125;&#125; 使用示例 1_instanceof(b, A) //true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"new的原理及手写实现","slug":"new的原理及手写实现","date":"2019-08-21T05:00:09.000Z","updated":"2019-08-21T05:21:10.181Z","comments":true,"path":"2019/08/21/new的原理及手写实现/","link":"","permalink":"https://romancy.github.io/2019/08/21/new的原理及手写实现/","excerpt":"","text":"new 的作用 创建一个新对象 把obj的proto指向Object的prototype 实现继承 执行构造函数，传递参数，改变this指向 最后赋值给变量 手写实现 1234567891011121314const _new = function()&#123; const constructor = Array.prototype.shift.call(arguments); // 创建一个新对象 const obj = new Object(); // 把obj的__proto__指向Object的prototype obj.__proto__ = constructor.prototype; // 执行构造函数，传递参数，改变this执行 constructor.apply(obj, Array.prototype.slice.apply(arguments)); return obj&#125; 使用示例 1234567891011function Dog(name)&#123; this.name = name;&#125;Dog.prototype.getName = function()&#123; return this.name;&#125;let dog = _new(Dog, '小狗');console.log(dog.name) // 小狗console.log(dog.getName()) // 小狗","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]}]}