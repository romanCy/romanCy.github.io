{"meta":{"title":"pdChen的博客","subtitle":"前端技术学习","description":null,"author":"chenyu","url":"https://romancy.github.io","root":"/"},"pages":[],"posts":[{"title":"如何发布一个npm包","slug":"如何发布一个npm包","date":"2019-08-21T09:58:56.000Z","updated":"2019-08-21T10:08:53.164Z","comments":true,"path":"2019/08/21/如何发布一个npm包/","link":"","permalink":"https://romancy.github.io/2019/08/21/如何发布一个npm包/","excerpt":"","text":"如何发布一个npm包 npm config set registry http://registry.npmjs.org npm get registry =&gt; http://registry.npmjs.org/ 登录 npm adduser Username: pdyu Password: Email: (this IS public) yu824562457@qq.com Logged in as pdyu on http://registry.npmjs.org/. npm publish pdc-cli-test@1.0.0","categories":[],"tags":[{"name":"utils","slug":"utils","permalink":"https://romancy.github.io/tags/utils/"}]},{"title":"node.js+commander写一个命令行工具","slug":"node-js-commander写一个命令行工具","date":"2019-08-21T06:23:45.000Z","updated":"2019-08-21T08:30:25.412Z","comments":true,"path":"2019/08/21/node-js-commander写一个命令行工具/","link":"","permalink":"https://romancy.github.io/2019/08/21/node-js-commander写一个命令行工具/","excerpt":"","text":"node.js + commander 写一个命令行工具环境搭建安装node略 初始化项目 mkdir pdc-cli &amp;&amp; cd pdc-cli npm init 安装依赖包 npm i commander –save npm i chalk –save 颜色包 npm i ora –save loading包 npm i inquirer –save 与用户交互包 npm i handlebars –save 模板渲染包 npm i log-symbols –save 终端图标包 根目录新建index.js touch index.js 编写index.js#!/usr/bin/env node在代码的开头第一行，必须指定我们的脚本执行所需要的解释程序。在这里，我们使用node来作为脚本的解释程序。而我们#! /usr/bin/env node这样写，目的是使用env来找到node，并使用node来作为程序的解释程序。 先写一个最简单的在index.js中编辑以下代码 123456789101112#!/usr/bin/env nodeconst program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')program.version(`$&#123;packageInfo.version&#125;`, '-v --version')program.parse(process.argv) 在package.json中配置命令名称及入口 123\"bin\": &#123; \"pdc\": \"index.js\"&#125; 把包link到本地全局，在项目根目录执行 npm link 在命令行输入 pdc -v 或者 pdc –version 终端会显示package.json中的version字段的值 写一个能接受用户参数的cli编辑index.js 123456789101112131415161718#!/usr/bin/env nodeconst program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; console.log(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) &#125;)program.parse(process.argv) 在命令行输入 pdc init -n test -t .src 终端输出 你输入的名字是test, 你输入的目录是.src 写一个模板拷贝的cli工具12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')// 拷贝文件到目录function copyTo(name, target)&#123; // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; console.log(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(cmd.name, cmd.target); &#125;)program.parse(process.argv) 美化一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')// 打印日志工具 不同颜色const logger = &#123; notice (msg) &#123; process.stdout.write('\\n' + chalk.cyan('[INFO]') + ' ' + msg + '\\n') &#125;, warn (msg) &#123; process.stdout.write('\\n' + chalk.yellow('[WARN]') + ' ' + msg + '\\n') &#125;, error (msg) &#123; process.stdout.write('\\n' + chalk.red('[ERROR]') + ' ' + msg + '\\n') &#125;&#125;// 拷贝文件到目录function copyTo(name, target)&#123; // loading const spinner = ora('正在拷贝...') spinner.start() // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; spinner.succeed() throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) // loading成功 spinner.succeed() // 显示成功 console.log(symbols.success, chalk.green('success')) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; logger.notice(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(cmd.name, cmd.target); &#125;)program.parse(process.argv) 换成交互式选择模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')const logger = &#123; notice (msg) &#123; process.stdout.write('\\n' + chalk.cyan('[INFO]') + ' ' + msg + '\\n') &#125;, warn (msg) &#123; process.stdout.write('\\n' + chalk.yellow('[WARN]') + ' ' + msg + '\\n') &#125;, error (msg) &#123; process.stdout.write('\\n' + chalk.red('[ERROR]') + ' ' + msg + '\\n') &#125;&#125;// 拷贝文件到目录function copyTo(name, target)&#123; const spinner = ora('正在拷贝...') spinner.start() // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; spinner.succeed() throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') // .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; // 换成可选择的 inquirer.prompt([ &#123; type: 'list', name: 'name', message: 'template name', choices: [ 'a.js', 'b.js' ] &#125; ]).then(answers =&gt; &#123; logger.notice(`你输入的名字是$&#123;answers.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(answers.name, cmd.target); &#125;) &#125;)program.parse(process.argv)","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://romancy.github.io/tags/node/"}]},{"title":"获取类型","slug":"获取类型","date":"2019-08-21T06:05:58.000Z","updated":"2019-08-21T06:06:58.085Z","comments":true,"path":"2019/08/21/获取类型/","link":"","permalink":"https://romancy.github.io/2019/08/21/获取类型/","excerpt":"","text":"能够准确获取类型如下 1234567891011121314// typeoffunction type(obj) &#123; return typeof obj !== \"object\" ? typeof obj : Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();&#125;console.log(type(1)) //numberconsole.log(type(true)) //booleanconsole.log(type('22')) //stringconsole.log(type([221,2])) //arrayconsole.log(type(&#123;a:1&#125;)) //objectconsole.log(type(new String('22'))) //stringconsole.log(type(null)) //nullconsole.log(type(undefined)) //undefinedconsole.log(type(/sd/)) //regexp","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"日期格式化","slug":"日期格式化","date":"2019-08-21T06:00:22.000Z","updated":"2019-08-21T06:01:57.456Z","comments":true,"path":"2019/08/21/日期格式化/","link":"","permalink":"https://romancy.github.io/2019/08/21/日期格式化/","excerpt":"","text":"主要是正则进行文本替换 上代码 12345678910111213141516171819202122Date.prototype.format = function (format) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //month \"d+\": this.getDate(), //day \"h+\": this.getHours(), //hour \"m+\": this.getMinutes(), //minute \"s+\": this.getSeconds(), //second \"q+\": Math.floor((this.getMonth() + 3) / 3), //quarter \"S\": this.getMilliseconds() //millisecond &#125; if (/(y+)/.test(format)) format = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(format)) format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length)); return format;&#125;;let time = new Date().format('yyyy-MM-dd hh:mm:ss')console.log(time)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"instanceof的原理及手写实现","slug":"instanceof的原理及手写实现","date":"2019-08-21T05:28:14.000Z","updated":"2019-08-21T05:52:59.443Z","comments":true,"path":"2019/08/21/instanceof的原理及手写实现/","link":"","permalink":"https://romancy.github.io/2019/08/21/instanceof的原理及手写实现/","excerpt":"","text":"instanceof 的作用简单说，instanceof的主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。 12345678910111213// A对象function A()&#123;&#125;// B对象继承A(组合继承)function B()&#123; A.apply(this, arguments)&#125;B.prototype = Object.create(A.prototype)let b = new B()console.log(b instanceof A) // true 手写实现 1234567891011121314151617function _instanceof(left, right)&#123; let _prototype = right.prototype; let _proto = left.__proto__ while(true)&#123; // 找到头了 if(_proto === null)&#123; return false &#125; if(_proto === _prototype)&#123; return true &#125; _proto = _proto.__proto__ &#125;&#125; 使用示例 1_instanceof(b, A) //true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"new的原理及手写实现","slug":"new的原理及手写实现","date":"2019-08-21T05:00:09.000Z","updated":"2019-08-21T05:21:10.181Z","comments":true,"path":"2019/08/21/new的原理及手写实现/","link":"","permalink":"https://romancy.github.io/2019/08/21/new的原理及手写实现/","excerpt":"","text":"new 的作用 创建一个新对象 把obj的proto指向Object的prototype 实现继承 执行构造函数，传递参数，改变this指向 最后赋值给变量 手写实现 1234567891011121314const _new = function()&#123; const constructor = Array.prototype.shift.call(arguments); // 创建一个新对象 const obj = new Object(); // 把obj的__proto__指向Object的prototype obj.__proto__ = constructor.prototype; // 执行构造函数，传递参数，改变this执行 constructor.apply(obj, Array.prototype.slice.apply(arguments)); return obj&#125; 使用示例 1234567891011function Dog(name)&#123; this.name = name;&#125;Dog.prototype.getName = function()&#123; return this.name;&#125;let dog = _new(Dog, '小狗');console.log(dog.name) // 小狗console.log(dog.getName()) // 小狗","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]}]}