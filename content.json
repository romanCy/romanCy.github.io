{"meta":{"title":"pdChen的博客","subtitle":"前端技术学习","description":null,"author":"chenyu","url":"https://romancy.github.io","root":"/"},"pages":[],"posts":[{"title":"Git操作熟悉","slug":"Git操作熟悉","date":"2019-11-07T03:19:43.000Z","updated":"2019-11-07T03:28:09.813Z","comments":true,"path":"2019/11/07/Git操作熟悉/","link":"","permalink":"https://romancy.github.io/2019/11/07/Git操作熟悉/","excerpt":"","text":"重命名本地分支 git branch -m currentName newName 缓存本地改变 git stash 把缓存取出来 git stash pop stash{0} 对比分支间的改变 git diff branchName branchName 回滚到某个commit git log git reset –hard commitId 提交回滚 git push -force","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://romancy.github.io/tags/Git/"}]},{"title":"理解promise","slug":"理解promise","date":"2019-11-06T11:30:00.000Z","updated":"2019-11-07T04:34:16.983Z","comments":true,"path":"2019/11/06/理解promise/","link":"","permalink":"https://romancy.github.io/2019/11/06/理解promise/","excerpt":"","text":"理解Promise解决回调地狱123456789101112131415function sendAjax(cb) &#123; setTimeout(() =&gt; &#123; cb(new Date().getTime()) &#125;, 1000)&#125;sendAjax((data1) =&gt; &#123; console.log(data1) sendAjax((data2) =&gt; &#123; console.log(data2) sendAjax((data3) =&gt; &#123; console.log(data3) &#125;) &#125;)&#125;) 用promise梳理上述代码,解决了回调地狱，也有更好的语义化，每次then之后发出返回新的Promise对象发送请求。 1234567891011121314151617function promiseSendAjax() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(new Date().getTime()) &#125;, 1000) &#125;)&#125;promiseSendAjax().then((res) =&gt; &#123; console.log(res) return promiseSendAjax()&#125;).then((res) =&gt; &#123; console.log(res) return promiseSendAjax()&#125;).then((res) =&gt; &#123; console.log(res)&#125;) Promise的静态方法Promise.resolve 返回成功状态的Promise对象 123let p1 = Promise.resolve('success').then((res) =&gt; &#123; console.log(res) //success&#125;) Promise.reject 返回失败状态的Promise对象 123let p2 = Promise.reject('error').then((res) =&gt; &#123; &#125;, err =&gt; &#123; console.log(err) //error&#125;) Promise.all 接收一个Promise对象数组为参数 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111) &#125;, 1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(222) &#125;, 2000)&#125;)Promise.all([p1, p2]).then(res =&gt; &#123; console.log(res) //[ 111, 222 ]&#125;, err =&gt; &#123; console.log(err)&#125;) 如果其中一个或多个报错了，那么即返回第一个reject 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111) &#125;, 1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(222) &#125;, 2000)&#125;)Promise.all([p1, p2]).then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err) //222&#125;) Promise.race 接受promise对象数组，其中一个状态有变化即处理后边的逻辑，只需要一个promise对象状态的变化 123456789101112131415let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111) &#125;, 1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(222) &#125;, 3000)&#125;)Promise.race([p1, p2]).then(res =&gt; &#123; console.log(res) //1s之后打印111&#125;) 手写简易Promise（没有链式调用）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Mypromise &#123; constructor(cb) &#123; // 三个状态 pending fulfilled rejected this.state = 'pending' // 成功时的值 this.value = undefined // 错误时的值 this.reason = undefined // 要想异步调用then 加一个发布订阅 this.ResolvedCbs = [] this.RejectedCbs = [] let resolve = (value) =&gt; &#123; // resolve调用后 state 变为fulfilled if (this.state === 'pending') &#123; this.state = 'fulfilled' this.value = value // 一旦resolve执行，调用成功数组的函数 要用forEach 是因为可能有多个then this.ResolvedCbs.forEach(fn =&gt; fn()) &#125; &#125; let reject = (reason) =&gt; &#123; // reject 调用后 state 变为rejected if (this.state === 'pending') &#123; this.state = 'rejected' this.reason = reason this.RejectedCbs.forEach(fn =&gt; fn()) &#125; &#125; try &#123; cb(resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125; // promise规定 有一个叫做then的方法 接受两个参数 onFulfilled,onRejected then(onFulfilled, onRejected) &#123; if (this.state === 'fulfilled') &#123; onFulfilled(this.value) &#125; if (this.state === 'rejected') &#123; onRejected(this.reason) &#125; // 当状态为pending时先存到对应数组中 if (this.state === 'pending') &#123; this.ResolvedCbs.push(() =&gt; &#123; onFulfilled(this.value) &#125;) this.RejectedCbs.push(() =&gt; &#123; onRejected(this.value) &#125;) &#125; &#125;&#125;// let p = new Mypromise((resolve, reject) =&gt; &#123;// resolve('heool')// &#125;).then((res) =&gt; &#123;// console.log(res)// &#125;)let p2 = new Mypromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('111') &#125;, 1000)&#125;)p2.then((res) =&gt; &#123; console.log(res)&#125;)p2.then((res) =&gt; &#123; console.log(`pd$&#123;res&#125;`)&#125;)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"惰性函数","slug":"惰性函数","date":"2019-11-06T10:49:10.000Z","updated":"2019-11-06T11:11:46.684Z","comments":true,"path":"2019/11/06/惰性函数/","link":"","permalink":"https://romancy.github.io/2019/11/06/惰性函数/","excerpt":"","text":"惰性函数的作用与写法场景：定义一个getFirstTime方法，用来初始化第一次调用该方法时的时间 利用全局变量12345678var t=null;function getFirstTime()&#123; if(t===null)&#123; t=new Date().getTime() return t &#125; return t;&#125; 缺点每次需要判断，并且污染全局变量 利用闭包123456789101112function foo()&#123; let t = null; return function()&#123; if(t===null)&#123; t=new Date().getTime(); return t &#125; return t &#125;&#125;let getFirstTime = foo() 缺点还是每次需要判断 利用惰性函数1234567function getFirstTime()&#123; let t = new Date(); getFirstTime = ()=&gt;&#123; return t &#125; return getFirstTime()&#125; 再写一个例子初始化时候打印“初始化”，以后再调用打印“初始化过了” 123456function goo()&#123; console.log('初始化') goo=function()&#123; console.log('初始化过了') &#125;&#125; 再写一个判断浏览器环境的例子123456789function getIsIos()&#123; const ua = navigator.userAgent; isIos = /iphone|ipod|ipad/i.test(ua); getIsIos=function()&#123; console.log('我曾经告诉过你') return isIos &#125; return isIos&#125; 大概明白了吧~","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"vue文字竖向轮播","slug":"vue文字竖向轮播","date":"2019-11-05T07:33:45.000Z","updated":"2019-11-05T07:35:50.556Z","comments":true,"path":"2019/11/05/vue文字竖向轮播/","link":"","permalink":"https://romancy.github.io/2019/11/05/vue文字竖向轮播/","excerpt":"","text":"80行简单文字轮播1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;template&gt; &lt;div rel='newBroadCast'&gt; &lt;div class=\"broad-content\"&gt; &lt;div id=\"prevEl\" class=\"broad-prev\" :class=\"&#123;'run-broad-prev': isRun&#125;\"&gt;&#123;&#123;prevMsg&#125;&#125;&lt;/div&gt; &lt;div class=\"broad-next\"&gt;&#123;&#123;nextMsg&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'newBroadCast', props: ['list'], watch: &#123; list: &#123; handler(v) &#123; this.$nextTick(() =&gt; &#123; this.moveInfo(); &#125;); &#125;, immediate: true &#125; &#125;, data() &#123; return &#123; isRun: false, interval: 2500, timer: null, prevMsg: '', nextMsg: '', current: 0 &#125;; &#125;, methods: &#123; moveInfo() &#123; this.prevMsg = this.list[this.current]; this.nextMsg = (this.current + 1) &gt;= this.list.length ? this.list[0] : this.list[this.current + 1]; this.timer = setTimeout(() =&gt; &#123; this.isRun = true; &#125;, this.interval); &#125; &#125;, mounted() &#123; this.$nextTick(() =&gt; &#123; const prevEl = document.getElementById('prevEl'); // 动画结束 prevEl.addEventListener('animationend', () =&gt; &#123; this.current++; if (this.current &gt;= this.list.length) &#123; this.current = 0; &#125; this.isRun = false; this.moveInfo(); &#125;); &#125;); &#125;, destroyed() &#123; clearTimeout(this.timer); &#125;&#125;;&lt;/script&gt;&lt;style lang='scss'&gt;div[rel=\"newBroadCast\"] &#123; width: 100%; height: 1.4rem; overflow: hidden; .run-broad-prev &#123; margin-top: -0.7rem; animation: prevMv 0.5s linear; &#125;&#125;@keyframes prevMv &#123; 0% &#123; margin-top: 0%; &#125; 100% &#123; margin-top: -0.7rem; &#125;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://romancy.github.io/tags/Vue/"}]},{"title":"前端跨域解析及解决","slug":"前端跨域解析及解决","date":"2019-10-24T12:18:28.000Z","updated":"2019-10-24T12:19:24.603Z","comments":true,"path":"2019/10/24/前端跨域解析及解决/","link":"","permalink":"https://romancy.github.io/2019/10/24/前端跨域解析及解决/","excerpt":"","text":"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"监听页面滑动到底部","slug":"监听页面滑动到底部","date":"2019-10-22T06:04:26.000Z","updated":"2019-10-22T06:07:41.255Z","comments":true,"path":"2019/10/22/监听页面滑动到底部/","link":"","permalink":"https://romancy.github.io/2019/10/22/监听页面滑动到底部/","excerpt":"","text":"监听页面滑动到底部12345678910111213window.onscroll = function()&#123; //变量scrollTop是滚动条滚动时，距离顶部的距离 var scrollTop = document.documentElement.scrollTop||document.body.scrollTop; //变量windowHeight是可视区的高度 var windowHeight = document.documentElement.clientHeight || document.body.clientHeight; //变量scrollHeight是滚动条的总高度 var scrollHeight = document.documentElement.scrollHeight||document.body.scrollHeight; //滚动条到底部的条件 if(scrollTop+windowHeight==scrollHeight)&#123; //写后台加载数据的函数 console.log(\"距顶部\"+scrollTop+\"可视区高度\"+windowHeight+\"滚动条总高度\"+scrollHeight); &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"CentOs搭建NodeJs服务器(nginx安装)","slug":"CentOs搭建NodeJs服务器-nginx安装","date":"2019-10-16T11:45:23.000Z","updated":"2019-10-16T11:52:20.876Z","comments":true,"path":"2019/10/16/CentOs搭建NodeJs服务器-nginx安装/","link":"","permalink":"https://romancy.github.io/2019/10/16/CentOs搭建NodeJs服务器-nginx安装/","excerpt":"","text":"安装 nginx首先安装必要的库（nginx 中 gzip 模块需要 zlib 库，rewrite 模块需要 pcre 库，ssl 功能需要 openssl 库）。选定/usr/local为安装目录，以下具体版本号根据实际改变。 安装 gcc gcc-c++(如新环境,未安装请先安装) yum install -y gcc gcc-c++ 安装 PCRE 库 cd /usr/local/ wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz tar -zxvf pcre-8.36.tar.gz cd pcre-8.36 ./configure make &amp;&amp; make install 如报错:configure: error: You need a C++ compiler for C++ support yum install -y gcc gcc-c++ 安装 SSL 库 cd /usr/local/ wget http://www.openssl.org/source/openssl-1.0.1j.tar.gz tar -zxvf openssl-1.0.1j.tar.gz cd openssl-1.0.1j ./config make &amp;&amp; make install 安装 zlib 库存 cd /usr/local/ wget http://zlib.net/zlib-1.2.11.tar.gz tar -zxvf zlib-1.2.11.tar.gz ./configure make &amp;&amp; make install 安装 nginx cd /usr/local/ wget http://nginx.org/download/nginx-1.8.0.tar.gz tar -zxvf nginx-1.8.0.tar.gz cd nginx-1.8.0 ./configure –user=nobody –group=nobody –prefix=/usr/local/nginx –with-http_stub_status_module –with-http_gzip_static_module –with-http_realip_module –with-http_sub_module –with-http_ssl_module (注: –with-http_ssl_module:这个不加后面在 nginx.conf 配置 ssl:on 后,启动会报 nginx: [emerg] unknown directive “ssl” in /opt/nginx/conf/nginx.conf 异常) make &amp;&amp; make install 时提示以下错误： ./configure: error: SSL modules require the OpenSSL library. 支持此命令： yum -y install openssl openssl-devel 报错:./configure: error: the HTTP gzip module requires the zlib library 在–prefix 后面接以下命令: –with-pcre=/usr/local/pcre-8.36 指的是 pcre-8.36 的源码路径。–with-zlib=/usr/local/zlib-1.2.8 指的是 zlib-1.2.8 的源码路径。 点击此处下载安装脚本 启动 /usr/local/nginx/sbin/nginx 检查是否启动成功： 打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。 部分命令如下：重启： /usr/local/nginx/sbin/nginx –s reload 停止： /usr/local/nginx/sbin/nginx –s stop 测试配置文件是否正常： /usr/local/nginx/sbin/nginx –t 强制关闭： pkill nginx","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://romancy.github.io/tags/node/"}]},{"title":"CentOs搭建NodeJs服务器","slug":"CentOs搭建NodeJs服务器—-Node安装","date":"2019-10-16T11:38:12.000Z","updated":"2019-10-16T11:42:15.803Z","comments":true,"path":"2019/10/16/CentOs搭建NodeJs服务器—-Node安装/","link":"","permalink":"https://romancy.github.io/2019/10/16/CentOs搭建NodeJs服务器—-Node安装/","excerpt":"","text":"安装 node 下载 node 下载 Node（随便找个目录新建个目录存放关于 Node 的文件，便于管理寻找）版本号可以根据 NodeJs 官网的版本号填写 wget https://npm.taobao.org/mirrors/node/v8.11.0/node-v8.11.0-linux-x64.tar.xz 解压 tar -xvf node-v8.11.0-linux-x64.tar.xz 测试 cd tar -xvf node-v8.0.0-linux-x64.tar.xz/bin ./node -v 配置全局环境变量 ln -s &lt;路径&gt;/bin/node /usr/local/bin/node ln -s &lt;路径&gt;/bin/npm /usr/local/bin/npm 例：ln -s /node/node_install_path/node-v8.11.0-linux-x64/bin/node /usr/local/bin/node 然后可以用 pm2 或者 forever 去启动你的 node 服务","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://romancy.github.io/tags/node/"}]},{"title":"video移动端兼容","slug":"video移动端兼容","date":"2019-10-09T09:09:37.000Z","updated":"2019-10-09T09:10:41.649Z","comments":true,"path":"2019/10/09/video移动端兼容/","link":"","permalink":"https://romancy.github.io/2019/10/09/video移动端兼容/","excerpt":"","text":"内嵌许多小视频，在 ios 和安卓手机上播放时，遇到不少问题： 在微信浏览器内播放时，视频会自动全屏如果每个视频都有一张自定义的图片作为封面，在显示视频的同时，如果没有给这个视频设置高度，视频的容器在安卓手机上会被视频的封面撑大到变形 12345678910111213&lt;video class=\"video-source\" width=\"100%\" height=\"240px\" /*如果有封面，请设置高度*/ controls /*这个属性规定浏览器为该视频提供播放控件*/ style=\"object-fit:fill\" /*加这个style会让 Android / web 的视频在微信里的视频全屏，如果是在手机上预览，会让视频的封面同视频一样大小*/ webkit-playsinline=\"true\" /*这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放*/ x-webkit-airplay=\"true\" /*这个属性还不知道作用*/ playsinline=\"true\" /*IOS微信浏览器支持小窗内播放*/ x5-video-player-type=\"h5\" /*启用H5播放器,是wechat安卓版特性*/ x5-video-orientation=\"h5\" /*播放器支付的方向，landscape横屏，portraint竖屏，默认值为竖屏*/ x5-video-player-fullscreen=\"true\" /*全屏设置，设置为 true 是防止横屏*/ preload=\"auto\" /*这个属性规定页面加载完成后载入视频*/&lt;/video&gt;","categories":[],"tags":[{"name":"Html","slug":"Html","permalink":"https://romancy.github.io/tags/Html/"}]},{"title":"高性能列表渲染","slug":"高性能列表渲染","date":"2019-09-29T07:43:36.000Z","updated":"2019-09-29T07:43:59.346Z","comments":true,"path":"2019/09/29/高性能列表渲染/","link":"","permalink":"https://romancy.github.io/2019/09/29/高性能列表渲染/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"container\"&gt;&lt;/ul&gt; &lt;/body&gt; &lt;script&gt; // normal function normalR() &#123; // 记录任务开始时间 let now = Date.now(); // 插入十万条数据 const total = 100000; // 获取容器 let ul = document.getElementById(\"container\"); // 将数据插入容器中 for (let i = 0; i &lt; total; i++) &#123; let li = document.createElement(\"li\"); li.innerText = ~~(Math.random() * total); ul.appendChild(li); &#125; console.log(\"JS运行时间：\", Date.now() - now); setTimeout(() =&gt; &#123; console.log(\"总运行时间：\", Date.now() - now); &#125;, 0); &#125; window.onload = function() &#123; //需要插入的容器 let ul = document.getElementById(\"container\"); // 插入十万条数据 let total = 100000; // 一次插入 20 条 let once = 20; //总页数 let page = total / once; //每条记录的索引 let index = 0; //循环加载数据 function loop(curTotal, curIndex) &#123; if (curTotal &lt;= 0) &#123; return false; &#125; //每页多少条 let pageCount = Math.min(curTotal, once); window.requestAnimationFrame(function() &#123; for (let i = 0; i &lt; pageCount; i++) &#123; let li = document.createElement(\"li\"); li.innerText = curIndex + i + \" : \" + ~~(Math.random() * total); ul.appendChild(li); &#125; loop(curTotal - pageCount, curIndex + pageCount); &#125;); &#125; loop(total, index); &#125;; &lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"防抖和节流","slug":"防抖和节流","date":"2019-09-29T07:20:23.000Z","updated":"2019-09-29T07:21:03.638Z","comments":true,"path":"2019/09/29/防抖和节流/","link":"","permalink":"https://romancy.github.io/2019/09/29/防抖和节流/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body style=\"height:2000px;\"&gt;&lt;/body&gt;&lt;script&gt; function debounce(fn, wait) &#123; let timer = null; return function () &#123; if (timer) &#123; clearTimeout(timer) &#125; let self = this let args = arguments timer = setTimeout(() =&gt; &#123; fn.apply(self, args) &#125;, wait) &#125; &#125; function previous(fn, wait) &#123; let preTime = 0; return function () &#123; let self = this; let args = arguments; let now = Date.now() if (now - preTime &gt; wait) &#123; if (preTime === 0) &#123; preTime = now return; &#125; fn.apply(this, args) preTime = now &#125; &#125; &#125; window.onload = function () &#123; // 防抖 // window.onscroll = debounce(function () &#123; // console.log('gundong') // &#125;, 1000) // 节流 window.onscroll = previous(() =&gt; &#123; console.log(11) &#125;, 1000) &#125;&lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"移动端刮刮卡简单实现","slug":"移动端刮刮卡简单实现","date":"2019-09-29T03:55:50.000Z","updated":"2019-09-29T06:23:23.463Z","comments":true,"path":"2019/09/29/移动端刮刮卡简单实现/","link":"","permalink":"https://romancy.github.io/2019/09/29/移动端刮刮卡简单实现/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .canvasWrap &#123; width: 300px; height: 200px; border: 1px solid #000; &#125; #myCanvas &#123; background: #ccc; width: 300px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"canvasWrap\"&gt; &lt;canvas id=\"myCanvas\"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.onload = function() &#123; let canvas = document.getElementById(\"myCanvas\"); canvas.width = 300; canvas.height = 200; new ScratchCard(canvas, \"blue\").createScratchCard(); &#125;; class ScratchCard &#123; constructor(el, fullColor = \"#ffffff\", radius = 25) &#123; this.el = el; this.fullColor = fullColor; this.radius = radius; &#125; createScratchCard() &#123; const context = this.el.getContext(\"2d\"); context.fillStyle = this.fullColor; context.fillRect(0, 0, this.el.width, this.el.height); this.el.ontouchmove = ev =&gt; &#123; this.clearArcFun( ev.changedTouches[0].clientX, ev.changedTouches[0].clientY, this.radius, context ); &#125;; this.el.ontouchend = () =&gt; &#123; this.clearAll(context, 70, () =&gt; &#123; alert(\"清除大于百分之70\"); &#125;); &#125;; &#125; clearAll(ctx, percentage, fn) &#123; let pxpoint = ctx.getImageData(0, 0, 300, 200).data; let transpantP = 0; for (let i = 0; i &lt; pxpoint.length; i++) &#123; if (pxpoint[i] === 0) &#123; transpantP++; &#125; &#125; let p = (transpantP / pxpoint.length) * 100; if (p &gt; percentage) &#123; ctx.clearRect(0, 0, this.el.width, this.el.height); fn &amp;&amp; fn(); &#125; &#125; clearArcFun(x, y, r, cxt) &#123; var stepClear = 1; clearArc(x, y, r); function clearArc(x, y, radius) &#123; var calcWidth = radius - stepClear; var calcHeight = Math.sqrt(radius * radius - calcWidth * calcWidth); var posX = x - calcWidth; var posY = y - calcHeight; var widthX = 2 * calcWidth; var heightY = 2 * calcHeight; if (stepClear &lt;= radius) &#123; cxt.clearRect(posX, posY, widthX, heightY); stepClear += 1; clearArc(x, y, radius); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"jq extend源码","slug":"jq-extend源码","date":"2019-09-24T03:06:53.000Z","updated":"2019-09-24T03:07:13.121Z","comments":true,"path":"2019/09/24/jq-extend源码/","link":"","permalink":"https://romancy.github.io/2019/09/24/jq-extend源码/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* eslint-disable */let class2type = (function () &#123; let class2type = &#123;&#125;; let arr = 'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '); arr.forEach(function (name) &#123; class2type['[object ' + name + ']'] = name.toLowerCase(); &#125;); return class2type;&#125;)();let _type = function (obj) &#123; if (obj == null) &#123; return obj + ''; &#125; return typeof obj === 'object' || typeof obj === 'function' ? class2type[&#123;&#125;.toString.call(obj)] || 'object' : typeof obj;&#125;;let isArray = Array.isArray;let isFunction = function (obj) &#123; return _type(obj) === 'function';&#125;;let isPlainObject = function (obj) &#123; return _type(obj) === 'object';&#125;;let extend = function () &#123; let src, copyIsArray, copy, name, options, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if (typeof target === 'boolean') &#123; deep = target; // skip the boolean and the target target = arguments[i] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if (typeof target !== 'object' &amp;&amp; !isFunction(target)) &#123; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if (i === length) &#123; target = this; i--; &#125; for (; i &lt; length; i++) &#123; // Only deal with non-null/undefined values if ((options = arguments[i]) != null) &#123; // Extend the base object for (name in options) &#123; src = target[name]; copy = options[name]; // Prevent never-ending loop if (target === copy) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[name] = extend(deep, clone, copy); // Don't bring in undefined values &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;export default extend;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"移动端rem处理-网易版","slug":"移动端rem处理-网易版","date":"2019-09-24T03:04:52.000Z","updated":"2019-09-24T03:05:28.806Z","comments":true,"path":"2019/09/24/移动端rem处理-网易版/","link":"","permalink":"https://romancy.github.io/2019/09/24/移动端rem处理-网易版/","excerpt":"","text":"在项目中添加 12345678910111213141516171819202122(function (doc, win) &#123; const docEl = doc.documentElement; const isIOS = navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); const scale = 1; const resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; docEl.dataset.dpr = 1; const metaEl = doc.createElement('meta'); metaEl.name = 'viewport'; metaEl.content = `initial-scale=$&#123;scale&#125;,maximum-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;`; docEl.firstElementChild.appendChild(metaEl); const recalc = function () &#123; const width = docEl.clientWidth; // if (width / 1 &gt; 750) &#123; // width = 750 * 1; // &#125; // 乘以100，px : rem = 100 : 1 docEl.style.fontSize = `$&#123;100 * (width / 750)&#125;px`; &#125;; recalc(); if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false);&#125;(document, window));","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"样式初始化reset.css","slug":"样式初始化reset-css","date":"2019-09-24T03:03:25.000Z","updated":"2019-09-24T03:03:59.596Z","comments":true,"path":"2019/09/24/样式初始化reset-css/","link":"","permalink":"https://romancy.github.io/2019/09/24/样式初始化reset-css/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin: 0; padding: 0;&#125;body &#123; background: #fff; color: #555; font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&#125;td,th,caption &#123; font-size: 14px;&#125;h1,h2,h3,h4,h5,h6 &#123; font-weight: normal; font-size: 100%;&#125;address,caption,cite,code,dfn,em,strong,th,var &#123; font-style: normal; font-weight: normal;&#125;a &#123; color: #555; text-decoration: none;&#125;a:hover &#123; text-decoration: underline;&#125;img &#123; border: none;&#125;ol,ul,li &#123; list-style: none;&#125;input,textarea,select,button &#123; font: 14px Verdana, Helvetica, Arial, sans-serif;&#125;table &#123; border-collapse: collapse;&#125;html &#123; overflow-y: scroll;&#125;.clearfix:after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; *zoom: 1;&#125;.Flex &#123; display: flex; display: -webkit-box; display: -moz-box; display: -webkit-flex; display: -moz-flex; display: -ms-flexbox;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://romancy.github.io/tags/CSS/"}]},{"title":"html反转义","slug":"html反转义","date":"2019-09-24T02:59:30.000Z","updated":"2019-09-24T03:01:12.662Z","comments":true,"path":"2019/09/24/html反转义/","link":"","permalink":"https://romancy.github.io/2019/09/24/html反转义/","excerpt":"","text":"原理: 先放到 div 容器里再取出来 1234567const escape2Html = (str) =&gt; &#123; let temp = document.createElement('div'); temp.innerHTML = str; const output = temp.innerText || temp.textContent; temp = null; return output;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"处理文字溢出","slug":"处理文字溢出","date":"2019-09-24T02:32:01.000Z","updated":"2019-09-24T02:34:55.161Z","comments":true,"path":"2019/09/24/处理文字溢出/","link":"","permalink":"https://romancy.github.io/2019/09/24/处理文字溢出/","excerpt":"","text":"行文字溢出1234/* 定宽 */overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 段落文字溢出1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;overflow: hidden;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://romancy.github.io/tags/CSS/"}]},{"title":"vue 以字符串形式渲染vue组件","slug":"vue-以字符串形式渲染vue组件","date":"2019-09-12T10:09:59.000Z","updated":"2019-09-12T10:11:49.756Z","comments":true,"path":"2019/09/12/vue-以字符串形式渲染vue组件/","link":"","permalink":"https://romancy.github.io/2019/09/12/vue-以字符串形式渲染vue组件/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div :class=&quot;$options.name&quot;&gt; &lt;cmp :html=&quot;el&quot;&gt;&lt;/cmp&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from &apos;vue&apos;;import AudioPlay from &apos;@/components/media/audioPlay&apos;;Vue.component(&apos;audio-play&apos;, AudioPlay);export default &#123; name: &apos;audio&apos;, data() &#123; return &#123; el: &apos;&lt;div&gt;&lt;audio-play&gt;&lt;/audio-play&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt;&apos; &#125;; &#125;, components: &#123; cmp: &#123; props: &#123; html: String &#125;, render(h) &#123; const com = Vue.extend(&#123; template: this.html &#125;) return h(com, &#123;&#125;) &#125; &#125; &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;sass&quot; scoped&gt;&lt;/style&gt;","categories":[],"tags":[]},{"title":"动态生成a标签进行下载","slug":"鍔ㄦ€佺敓鎴恆鏍囩杩涜涓嬭浇","date":"2019-09-09T03:19:50.000Z","updated":"2019-09-09T03:20:50.000Z","comments":true,"path":"2019/09/09/鍔ㄦ€佺敓鎴恆鏍囩杩涜涓嬭浇/","link":"","permalink":"https://romancy.github.io/2019/09/09/鍔ㄦ€佺敓鎴恆鏍囩杩涜涓嬭浇/","excerpt":"","text":"12345678910111213141516171819202122const randomString = function(len) &#123; len = len || 8; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;export default function (url) &#123; let a = document.createElement('a'); a.setAttribute('href', downloadUrl); a.setAttribute('id', hash); if(document.getElementById(hash)) &#123; document.body.removeChild(document.getElementById(hash)); &#125; document.body.appendChild(a); document.getElementById(hash).click(); document.body.removeChild(document.getElementById(hash));&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"indexedDB基础操作","slug":"indexedDB鍩虹鎿嶄綔","date":"2019-09-09T03:17:23.000Z","updated":"2019-09-09T03:17:54.000Z","comments":true,"path":"2019/09/09/indexedDB鍩虹鎿嶄綔/","link":"","permalink":"https://romancy.github.io/2019/09/09/indexedDB鍩虹鎿嶄綔/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class SetDB &#123; constructor() &#123; this.databaseName = ''; this.tableName = ''; this.db = null; this.indexedDB = null; &#125; init(databaseName, tableName) &#123; this.databaseName = databaseName; this.tableName = tableName; let self = this; this.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB; if (!this.indexedDB) &#123; console.log('你的浏览器不支持IndexedDB'); &#125; let IDBOpenDBRequest = this.indexedDB.open(self.databaseName, 1); IDBOpenDBRequest.onerror = function (e) &#123; console.log(e.currentTarget.error.message); &#125;; IDBOpenDBRequest.onupgradeneeded = function (e) &#123; self.db = e.target.result; // 获取到 demoDB对应的 IDBDatabase实例,也就是我们的数据库。 if (!self.db.objectStoreNames.contains(self.tableName)) &#123; //如果表格不存在，创建一个新的表格（keyPath，主键 ； autoIncrement,是否自增），会返回一个对象（objectStore） // objectStore就相当于数据库中的一张表。IDBObjectStore类型。 self.db.createObjectStore(self.tableName, &#123; keyPath: 'id', &#125;); &#125; &#125;; &#125; open(fn) &#123; let self = this; let IDBOpenDBRequest = this.indexedDB.open(self.databaseName, 1); IDBOpenDBRequest.onsuccess = function (e) &#123; fn &amp;&amp; fn(e.target.result) &#125;; &#125; add(data) &#123; let self = this; self.open(db =&gt; &#123; var transaction = db.transaction(self.tableName, 'readwrite'); // 通过事务来获取IDBObjectStore var store = transaction.objectStore(self.tableName); // 往store表中添加数据 var addPersonRequest = store.add(data); // 监听添加成功事件 addPersonRequest.onsuccess = function (e) &#123; console.log(e.target.result); // 打印添加成功数据的 主键（id） &#125;; // 监听失败事件 addPersonRequest.onerror = function (e) &#123; console.log(e.target.error); &#125;; &#125;) &#125; putData(data) &#123; let self = this; self.open(db =&gt; &#123; let store = db.transaction(self.tableName, 'readwrite').objectStore(self.tableName); let request = store.put(data); request.onerror = function () &#123; console.error('put添加数据库中已有该数据') &#125;; request.onsuccess = function () &#123; console.log('put添加数据已存入数据库') self.getAll(data =&gt; &#123; data.sort((a, b) =&gt; &#123; return b.time - a.time &#125;) for (let i = 100; i &lt; data.length; i++) &#123; // 删除超过数量的照片 self.deleteData(data[i].id) &#125; &#125;) &#125;; &#125;) &#125; getAll(callback) &#123; let self = this; this.open(db =&gt; &#123; let data = [] var transaction = db.transaction(self.tableName, 'readwrite'); var store = transaction.objectStore(self.tableName); var dataRequest = store.openCursor(); dataRequest.onsuccess = function (e) &#123; //异步的 let result = e.target.result; if (result &amp;&amp; result !== null) &#123; data.push(result.value); result.continue(); &#125; else &#123; console.log('全部查找数据成功') callback &amp;&amp; callback(data); &#125; &#125; &#125;) &#125; deleteData(key) &#123; let self = this; this.open(db =&gt; &#123; let store = db.transaction(self.tableName, 'readwrite').objectStore(self.tableName); let request = store.delete(key); request.onerror = function () &#123; console.error('删除失败') &#125;; request.onsuccess = function () &#123; console.log('删除成功') &#125;; &#125;) &#125; deleteDB() &#123; this.indexedDB.deleteDatabase(databaseName); &#125;&#125;export default new SetDB()","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"cookie操作","slug":"cookie鎿嶄綔","date":"2019-09-09T03:13:11.000Z","updated":"2019-09-09T03:14:36.000Z","comments":true,"path":"2019/09/09/cookie鎿嶄綔/","link":"","permalink":"https://romancy.github.io/2019/09/09/cookie鎿嶄綔/","excerpt":"","text":"1234567891011121314151617181920export default &#123; setCookie: function (cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = \"expires=\" + d.toUTCString(); document.cookie = cname + \"=\" + cvalue + \"; \" + expires; // console.info(document.cookie); &#125;,//获取cookie getCookie: function (cname) &#123; var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == ' ') c = c.substring(1); if (c.indexOf(name) != -1) return c.substring(name.length, c.length); &#125; return \"\"; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"我理解的js异步编程","slug":"鎴戠悊瑙ｇ殑js寮傛缂栫▼","date":"2019-09-09T02:22:20.000Z","updated":"2019-11-07T12:16:32.726Z","comments":true,"path":"2019/09/09/鎴戠悊瑙ｇ殑js寮傛缂栫▼/","link":"","permalink":"https://romancy.github.io/2019/09/09/鎴戠悊瑙ｇ殑js寮傛缂栫▼/","excerpt":"","text":"我理解的JavaScript异步编程引言最开始学习JS的时候就从知道了JS是单线程的，天生异步。但是，多数初学者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法，甚至于一直在用callback来解决异步问题。 为什么会出现异步浏览器内核的多线程 一个浏览器至少三个常驻线程：JavaScript引擎线程，浏览器GUI渲染线程，浏览器事件触发线程。 JS引擎，是基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。 GUI线程，当界面需要重绘或由于某种操作引发回流时，该线程就会执行。而因为JS可以操作DOM元素，进而会影响到GUI的渲染结果，因此JS引擎线程与GUI渲染线程是互斥的，也就是说当JS引擎线程处于运行状态时，GUI渲染线程将处于冻结状态。 浏览器事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待js引擎的处理，这些事件可来自JavaScript引擎当前执行的代码块，setTimeOut, 也可以来自浏览器内核的其他线程如鼠标点击，AJAX异步请求等，但由于JS的单线程关系，所有这些事件都得排队等待JS引擎处理。 事件循环机制 任务队列，也就是事件队列，分为 宏任务(macro-task) 和 微任务(micro-task) 循环机制如下 先顺序从上向下执行当前全局上下文 遇到异步事件就将其交给对应的浏览器模块 浏览器的模块处理完之后，宏任务放入宏任务队列，微任务放入微任务队列 当函数调用栈清空，开始执行任务队列，先执行微任务队列，执行完微任务队列再执行宏任务队列 当执行任务队列时，可以认为重新开了一个空的宏任务队列和一个空的微任务队列，将新产生的异步任务最终放入新的任务队列，当前任务队列执行完成后，当前宏队列和微队列就清除，然后再去执行新的微任务队列，执行新的宏任务队列，新开微队列，新开宏队列，一直循环下去，直到任务队列全部为空。 异步的处理方法callback是最简单的，但不是最好的12345678910111213141516171819//callback的一般使用形式$.ajax(&#123; url:'www.pidanChen.com' success:function(data)&#123; console.log(data) &#125;&#125;)//延时处理try&#123; setTimeout(function()&#123; console.log('timeout') &#125;,500)&#125;catch(e)&#123; console.log('timerErr'+e)&#125; 1.如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，还采用回调的方式来处理异步的话，就会出现回调地狱，也就是顺序问题。 2.最严重的还不是编辑器中出现的倒三角形的代码,是控制反转。例如，我们调用了一个第三方组件的支付API，进行购买支付，正常情况发现一切运行良好，但是假如某一天，第三方组件出问题了，可能多次调用传入的回调，也可能传回错误的数据。说到底，这样的回调嵌套，控制权在第三方，对于回调函数的调用方式、时间、次数、顺序，回调函数参数都是不可控的，因为无论如何，并不总能保证第三方是可信任的。 解决信任问题–Promise123456789//创建第一个Promiselet p = new Promise(function(res,rej)&#123; if(err)&#123; rej() &#125;else&#123; res() &#125;&#125;)p.then() 实例化一个Promise对象组要一个函数作为参数，该函数接受两个参数：resolve函数和reject函数；当实例化Promise构造函数时，将立即调用该函数，随后返回一个Promise对象。通常，实例化时，会初始一个异步任务，在异步任务完成或失败时，调用resolve或reject函数来完成或拒绝返回的Promise对象。另外需要注意的是，若传入的函数执行抛出异常，那么这个promsie将被拒绝。 解决控制反转的信任问题 Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。 它与普通的回调的方式的区别在于，普通的方式，回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。在Promise的方式中，回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。 Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。 解决调用过早Promise就根本不必担心这种问题即使是立即完成的Promise，也无法被同步观察到，即使这个Promise已经决议了，提供给then的回调总会是在js事件队列在当前完成后，再被调用，即异步调用。 解决回调过晚或没有调用Promise本身不会回调过晚，只要决议了，它就会按照规定运行。至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态API Promise.race加一个超时的时间 123456789function timeoutPromise(delay)&#123; return new Promise(function(res,rej)&#123; setTimeout(function()&#123; rej('timeout') &#125;, delay) &#125;)&#125;Promise.race([dosomeThing(), timeoutPromise(3000)]).then().catch() 解决回调次数太少或太多的问题由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。 12345678910111213141516171819let fs = require('fs');var p1 = new Promise(function (resolve, reject) &#123; fs.readFile('a.txt', 'utf8', function (err, data) &#123; if (err) &#123; reject(err); &#125; resolve(data); resolve(data); resolve(data); resolve(data); resolve(data); resolve(data); resolve(data); &#125;)&#125;);p1.then(function(res)&#123; &lt;!--只打印一次res--&gt; console.log(res)&#125;) 解决吞掉可能出现的错误或异常如果在Promise的创建过程中或在查看其决议结果的过程中的任何时间点上，出现了一个JavaScript异常错误，比如一个TypeError或ReferenceError，这个异常都会被捕捉，并且会使这个Promise被拒绝。 12345678910var p = new Promise(function (resolve, reject) &#123; foo.bar(); // foo未定义 resolve(2);&#125;);p.then(function (data) &#123; console.log(data); // 永远也不会到达这里&#125;, function (err) &#123; // console.log(err); // err将会是一个TypeError异常对象来自foo.bar()这一行&#125;); 从以上几点可以明确，Promise可以解决一系列控制反转带来的回调信任问题，但是Promise并没有完全摆脱回调，而是把回调的位置放到了then中，换成了决议通知，这样其实说到底顺序问题还是没有解决。。 解决顺序问题–Generator。生成器 (Generator)生成器是一种返回迭代器的函数，通过 function 关键字后的 * 号来表示。 迭代器（Iterable）迭代器是一种对象，它具有一些专门为迭代过程设计的专有接口，所有迭代器对象都有一个 next 方法，每次调用都返回一个结果对象。结果对象有两个属性，一个是 value，表示下一个将要返回的值；另一个是 done，它是一个布尔类型的值，当没有更多可返回数据时返回 true。迭代器还会保存一个内部指针，用来指向当前集合中值的位置，每调用一次 next() 方法，都会返回下一个可用的值。 生成器一般使用形式123456789101112function *foo() &#123; var x = yield 2; var y = x * (yield x + 1) console.log( x, y ); return x + y&#125;var it = foo();it.next() // &#123;value: 2, done: false&#125;it.next(3) // &#123;value: 4, done: false&#125;it.next(3) // 3 9, &#123;value: 12, done: true&#125; yield.. 和 next(..) 这一对组合起来， 在生成器的执行过程中构成了一个双向消息传递系统。 一般来说，需要的 next(..) 调用要比 yield 语句多一个，前面的代码片段有两个 yield 和三个 next(..) 调用； 第一个 next(..)是用来启动一个生成器，并运行到第一个 yield 处; 每个 yield.. 基本上是提出了一个问题：“这里我应该插入什么值？”，这个问题由下一个 next(..) 回答。 第二个 next(..) 回答第一个 yield.. 的问题，第三个 next(..) 回答第二个 yield 的问题，以此类推； yield.. 作为一个表达式可以发出消息响应 next(..) 调用， next(..) 也可以向暂停的 yield 表达式发送值。 异步迭代生成器来看一下下面这段代码，我们在生成器里 yeild 请求函数（暂停生成器继续执行，同时并执行请求函数），执行生成器产成可迭代对象后，又在请求函数里通过 next() 方法获取到请求结果、将结果传进生成器并恢复生成器的执行。 1234567891011121314151617181920212223242526272829//setTimeout 模拟ajax请求var it=nullfunction foo()&#123; let firstData='firstData' setTimeout(function()&#123; it.next(firstData) &#125;,500)&#125;function goo(data)&#123; let secondData='secondData' setTimeout(function()&#123; if(data=='firstData')&#123; it.next(`$&#123;secondData&#125;+$&#123;data&#125;`) &#125; &#125;,500)&#125;function *main()&#123; let data=yield foo() let newData=yield goo(data) console.log('经过两次异步之后输出结果:'+newData)&#125;it=main();it.next() //启动&lt;!--输出--&gt;经过两次异步之后输出结果:secondData+firstData 我们在生成器内部有了看似完全同步的代码（除了 yield 关键字本身），但隐藏在背后的是，在 foo(..) goo(…)内的运行可以完全异步。在可读性和合理性方面也都是一个巨大的进步。 从本质上而言，我们把异步作为实现细节抽象了出去，使得我们可以以同步顺序的形式追踪流程控制：“发出一个 Ajax 请求，等它完成之后打印出响应结果。”并且只在这个流程控制中表达了两个步骤，而这种表达能力是可以无限扩展的，以便我们无论需要多少步骤都可以表达。 由以上来看，顺序问题也得到了解决 es7的解决方案 Async/Await上面介绍的Promise和Generator，把这两者结合起来，就是Async/Await。 Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。 Async/Await是Generator的语法糖，和generator的写法很像，就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成await。 内置执行器：Generator函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器.也就是说，async 函数的执行，与普通函数一模一样。 更好的语义：async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 async 的作用async 函数负责返回一个 Promise 对象如果在async函数中 return 一个直接量，async 会把这个直接量通过Promise.resolve() 封装成 Promise 对象;如果 async 函数没有返回值,它会返回 Promise.resolve(undefined) await在等待什么一般我们都用await去等带一个async函数完成，不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值，所以，await后面实际可以接收普通函数调用或者直接量 如果await等到的不是一个promise对象，那跟着的表达式的运算结果就是它等到的东西；如果是一个promise对象，await会阻塞后面的代码，等promise对象resolve，得到resolve的值作为await表达式的运算结果虽然await阻塞了，但await在async中，async不会阻塞，它内部所有的阻塞都被封装在一个promise对象中异步执行 Async Await使用场景当需要用到promise链式调用的时候，就体现出Async Await的优势； 12345678910111213141516171819202122232425function delayTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return delayTime(n);&#125;function step2(m, n) &#123; console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`); return delayTime(m + n);&#125;async function main() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2);&#125;main();&lt;!--输出结果--&gt;step1 with 300step2 with 300 and 500 await 若等待的是 promise 就会停止下来例如：业务是这样的，我有三个异步请求需要发送，相互没有关联，只是需要当请求都结束后将界面的 loading 清除掉即可。 之前用callback这么写 1234567let lock=0ajax(function()&#123; lock++ if(lock===3)&#123; clearLoading()// 清除loading &#125;&#125;) 现在用 Async/Await 1234567// ajax方法返回的是promise对象async function doIt()&#123; await ajax(1) await ajax(2) await ajax(3) clearLoading()&#125; #####loading 确实是等待请求都结束完才清除的。但是观察下浏览器的 timeline 请求是一个结束后再发另一个的 正常应该是利用Promise.all + async 1234567async function doIt()&#123; let p1=ajax(1) let p2=ajax(2) let p3=ajax(3) await Promise.all([p1,p2,p3]); clearLoading()&#125; 所以async-await并不能取代promise，两者应该是相互配合。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"Vue工程搭建详细","slug":"Vue宸ョ▼鎼缓璇︾粏","date":"2019-09-06T07:06:48.000Z","updated":"2019-09-09T03:03:32.000Z","comments":true,"path":"2019/09/06/Vue宸ョ▼鎼缓璇︾粏/","link":"","permalink":"https://romancy.github.io/2019/09/06/Vue宸ョ▼鎼缓璇︾粏/","excerpt":"","text":"Vue工程搭建详细以下是我开始做vue以来所遇到的一些问题及解决方法环境搭建安装vue脚手架 npm i vue-cli -g 检验是否安装成功执行命令 vue -V 用webpack模板搭建vue工程 vue init webpack 进入到项目里安装依赖并执行启动命令 npm i &amp;&amp; npm run dev 打开浏览器访问127.0.0.1：8080即可看到 项目开发api封装在src目录下新建目录request，目录结构如下 api 为所有api配置，如method，url config 为基础配置 core 为所有核心api调用方法 index 入口 utils 工具方法 写好之后在项目main.js中进行挂载 1Vue.prototype['$myReq'] = request 详细代码：略 引入element安装 npm i element-ui -S 在工程main中添加引用 1234import elementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'Vue.use(elementUI) 然后在项目里就可以直接使用了 本地测试解决接口跨域问题在本地启动vue项目是常常会遇到接口跨域问题，解决方案有好多种。现在介绍的是个人认为最好用的方法，proxyTable。 用proxyTable的前提是要把大部分接口url比较统一如下面这样 那么proxyTable里面就可以写一套配置就可以了 1234567proxyTable: &#123; '/apis': &#123; // 测试环境 target: 'http://127.0.0.1:7001', // 接口域名 changeOrigin: true, //是否跨域 &#125;&#125;, 配置好之后再去访问就可以了","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://romancy.github.io/tags/Vue/"}]},{"title":"node核心模块--fs","slug":"node鏍稿績妯″潡-fs","date":"2019-08-22T03:28:31.000Z","updated":"2019-08-26T02:23:14.000Z","comments":true,"path":"2019/08/22/node鏍稿績妯″潡-fs/","link":"","permalink":"https://romancy.github.io/2019/08/22/node鏍稿績妯″潡-fs/","excerpt":"","text":"node核心模块–fs重命名文件","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://romancy.github.io/tags/node/"}]},{"title":"node.js+commander写一个命令行工具","slug":"node-js-commander鍐欎竴涓懡浠よ宸ュ叿","date":"2019-08-21T06:23:45.000Z","updated":"2019-08-22T02:26:34.000Z","comments":true,"path":"2019/08/21/node-js-commander鍐欎竴涓懡浠よ宸ュ叿/","link":"","permalink":"https://romancy.github.io/2019/08/21/node-js-commander鍐欎竴涓懡浠よ宸ュ叿/","excerpt":"","text":"node.js + commander 写一个命令行工具环境搭建安装node略 初始化项目 mkdir pdc-cli &amp;&amp; cd pdc-cli npm init 安装依赖包 npm i commander -S npm i chalk -S 颜色包 npm i ora -S loading包 npm i inquirer -S 与用户交互包 npm i handlebars -S 模板渲染包 npm i log-symbols -S 终端图标包 根目录新建index.js touch index.js 编写index.js#!/usr/bin/env node在代码的开头第一行，必须指定我们的脚本执行所需要的解释程序。在这里，我们使用node来作为脚本的解释程序。而我们#! /usr/bin/env node这样写，目的是使用env来找到node，并使用node来作为程序的解释程序。 先写一个最简单的在index.js中编辑以下代码 123456789101112#!/usr/bin/env nodeconst program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')program.version(`$&#123;packageInfo.version&#125;`, '-v --version')program.parse(process.argv) 在package.json中配置命令名称及入口 123\"bin\": &#123; \"pdc\": \"index.js\"&#125; 把包link到本地全局，在项目根目录执行 npm link 在命令行输入 pdc -v 或者 pdc –version 终端会显示package.json中的version字段的值 写一个能接受用户参数的cli编辑index.js 123456789101112131415161718#!/usr/bin/env nodeconst program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; console.log(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) &#125;)program.parse(process.argv) 在命令行输入 pdc init -n test -t .src 终端输出 你输入的名字是test, 你输入的目录是.src 写一个模板拷贝的cli工具12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')// 拷贝文件到目录function copyTo(name, target)&#123; // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; console.log(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(cmd.name, cmd.target); &#125;)program.parse(process.argv) 美化一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')// 打印日志工具 不同颜色const logger = &#123; notice (msg) &#123; process.stdout.write('\\n' + chalk.cyan('[INFO]') + ' ' + msg + '\\n') &#125;, warn (msg) &#123; process.stdout.write('\\n' + chalk.yellow('[WARN]') + ' ' + msg + '\\n') &#125;, error (msg) &#123; process.stdout.write('\\n' + chalk.red('[ERROR]') + ' ' + msg + '\\n') &#125;&#125;// 拷贝文件到目录function copyTo(name, target)&#123; // loading const spinner = ora('正在拷贝...') spinner.start() // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; spinner.succeed() throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) // loading成功 spinner.succeed() // 显示成功 console.log(symbols.success, chalk.green('success')) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; logger.notice(`你输入的名字是$&#123;cmd.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(cmd.name, cmd.target); &#125;)program.parse(process.argv) 换成交互式选择模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env nodeconst fs = require('fs');const path = require('path')const program = require('commander');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const packageInfo = require('./package.json')const logger = &#123; notice (msg) &#123; process.stdout.write('\\n' + chalk.cyan('[INFO]') + ' ' + msg + '\\n') &#125;, warn (msg) &#123; process.stdout.write('\\n' + chalk.yellow('[WARN]') + ' ' + msg + '\\n') &#125;, error (msg) &#123; process.stdout.write('\\n' + chalk.red('[ERROR]') + ' ' + msg + '\\n') &#125;&#125;// 拷贝文件到目录function copyTo(name, target)&#123; const spinner = ora('正在拷贝...') spinner.start() // 当前执行目录路径 const rootPath = process.cwd(); // 模板所在路径 const filePath = path.join(__dirname, '/templates/', name) // 目标路径 const targetPath = path.join(rootPath, target || `/src/`) // 判断模板是否存在 if(fs.existsSync(filePath))&#123; // 判断目标文件夹是否存在 if(fs.existsSync(targetPath))&#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; else &#123; // 新建文件夹 fs.mkdir(targetPath, 0777, (err) =&gt; &#123; if(err)&#123; spinner.succeed() throw err &#125; else &#123; // 拷贝 fs.copyFileSync(filePath, path.join(targetPath, name)) spinner.succeed() console.log(symbols.success, chalk.green('success')) &#125; &#125;) &#125; &#125;&#125;program.version(`$&#123;packageInfo.version&#125;`, '-v --version') .command('init') // .option('-n --name &lt;name&gt;', '名字') .option('-t --target &lt;target&gt;', '生成代码目录') .action( cmd =&gt; &#123; // 换成可选择的 inquirer.prompt([ &#123; type: 'list', name: 'name', message: 'template name', choices: [ 'a.js', 'b.js' ] &#125; ]).then(answers =&gt; &#123; logger.notice(`你输入的名字是$&#123;answers.name&#125;, 你输入的目录是$&#123;cmd.target&#125;`) copyTo(answers.name, cmd.target); &#125;) &#125;)program.parse(process.argv)","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://romancy.github.io/tags/node/"}]},{"title":"获取类型","slug":"鑾峰彇绫诲瀷","date":"2019-08-21T06:05:58.000Z","updated":"2019-08-21T06:06:58.000Z","comments":true,"path":"2019/08/21/鑾峰彇绫诲瀷/","link":"","permalink":"https://romancy.github.io/2019/08/21/鑾峰彇绫诲瀷/","excerpt":"","text":"能够准确获取类型如下 1234567891011121314// typeoffunction type(obj) &#123; return typeof obj !== \"object\" ? typeof obj : Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();&#125;console.log(type(1)) //numberconsole.log(type(true)) //booleanconsole.log(type('22')) //stringconsole.log(type([221,2])) //arrayconsole.log(type(&#123;a:1&#125;)) //objectconsole.log(type(new String('22'))) //stringconsole.log(type(null)) //nullconsole.log(type(undefined)) //undefinedconsole.log(type(/sd/)) //regexp","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"instanceof的原理及手写实现","slug":"instanceof鐨勫師鐞嗗強鎵嬪啓瀹炵幇","date":"2019-08-21T05:28:14.000Z","updated":"2019-08-21T05:53:00.000Z","comments":true,"path":"2019/08/21/instanceof鐨勫師鐞嗗強鎵嬪啓瀹炵幇/","link":"","permalink":"https://romancy.github.io/2019/08/21/instanceof鐨勫師鐞嗗強鎵嬪啓瀹炵幇/","excerpt":"","text":"instanceof 的作用简单说，instanceof的主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。 12345678910111213// A对象function A()&#123;&#125;// B对象继承A(组合继承)function B()&#123; A.apply(this, arguments)&#125;B.prototype = Object.create(A.prototype)let b = new B()console.log(b instanceof A) // true 手写实现 1234567891011121314151617function _instanceof(left, right)&#123; let _prototype = right.prototype; let _proto = left.__proto__ while(true)&#123; // 找到头了 if(_proto === null)&#123; return false &#125; if(_proto === _prototype)&#123; return true &#125; _proto = _proto.__proto__ &#125;&#125; 使用示例 1_instanceof(b, A) //true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]},{"title":"new的原理及手写实现","slug":"new鐨勫師鐞嗗強鎵嬪啓瀹炵幇","date":"2019-08-21T05:00:09.000Z","updated":"2019-08-21T05:21:10.000Z","comments":true,"path":"2019/08/21/new鐨勫師鐞嗗強鎵嬪啓瀹炵幇/","link":"","permalink":"https://romancy.github.io/2019/08/21/new鐨勫師鐞嗗強鎵嬪啓瀹炵幇/","excerpt":"","text":"new 的作用 创建一个新对象 把obj的proto指向Object的prototype 实现继承 执行构造函数，传递参数，改变this指向 最后赋值给变量 手写实现 1234567891011121314const _new = function()&#123; const constructor = Array.prototype.shift.call(arguments); // 创建一个新对象 const obj = new Object(); // 把obj的__proto__指向Object的prototype obj.__proto__ = constructor.prototype; // 执行构造函数，传递参数，改变this执行 constructor.apply(obj, Array.prototype.slice.apply(arguments)); return obj&#125; 使用示例 1234567891011function Dog(name)&#123; this.name = name;&#125;Dog.prototype.getName = function()&#123; return this.name;&#125;let dog = _new(Dog, '小狗');console.log(dog.name) // 小狗console.log(dog.getName()) // 小狗","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://romancy.github.io/tags/JavaScript/"}]}]}